# datatui Architecture Deep Dive

## Plugin Architecture Overview

```
┌─────────────────┐    JSON-RPC     ┌──────────────────┐
│   Nushell       │◄────────────────┤   datatui        │
│   Script        │                 │   Plugin         │
│                 │                 │                  │
│ • State mgmt    │    State +      │ • Terminal       │
│ • Event logic   │    UI Desc      │   control        │
│ • Data proc.    │                 │ • Ratatui        │ 
│ • Closures      │────────────────►│   rendering      │
└─────────────────┘                 │ • Event loop     │
                                    └──────────────────┘
```

## State Flow Cycle (Events-in-Render)

```
  1. Plugin collects events since last frame
                          │
                          ▼
  ┌─────────────────────────────────────────────────────┐
  │                 Nu Script                           │
  │                                                     │
  │  2. render(state, events) -> {                      │
  │       state: new_state,                             │
  │       ui: ui_description                            │
  │     }                                               │
  │                                                     │
  │  3. Process events with pattern matching            │
  │     Update state accordingly                        │
  │  4. Describe complete UI from new state             │
  └─────────────────────────────────────────────────────┘
                          │
                          │ {state: new_state, ui: ui_desc}
                          ▼
  ┌─────────────────────────────────────────────────────┐
  │               datatui Plugin                        │
  │                                                     │
  │  5. Store new_state for next frame                  │
  │  6. Render ui_description via ratatui               │
  │  7. Collect events (keyboard, mouse, resize)        │
  │  8. Tag events with widget_id based on focus       │
  └─────────────────────────────────────────────────────┘
                          │
                          │ Events for next frame
                          ▼
              Go to step 2 with (new_state, events)
```

## Data Structures

### State (Arbitrary Nu Record)
```nu
# Example application state - completely user-defined
{
  # UI state
  cursor: 5
  selected_view: "list"
  filter: "*.txt"
  
  # Application data  
  items: [
    {name: "file1.txt", size: 1024}
    {name: "file2.txt", size: 2048}
  ]
  
  # Dynamic content
  preview: "File contents here..."
  logs: ["Started", "Processing..."]
  
  # Computed values
  filtered_items: (computed from items + filter)
}
```

### Events List (Plugin → Nu)
```nu
# Events collected by plugin since last render, passed to render function
[
  {
    type: "key"
    key: "j" 
    widget_id: "file_list"
    modifiers: []
    timestamp: 1234567890
  }
  {
    type: "key"
    key: "enter"
    widget_id: "file_list" 
    modifiers: []
    timestamp: 1234567891
  }
  {
    type: "select"
    index: 3
    widget_id: "file_list"
    timestamp: 1234567892
  }
  {
    type: "resize" 
    width: 120
    height: 30
    timestamp: 1234567893
  }
]
```

### Render Function Output (Nu → Plugin)
```nu
# Generated by render function: render(state, events) -> result
{
  # Updated state for next frame
  state: {
    cursor: 3
    selected_file: "document.txt"
    preview: "Document contents here..."
    # ... rest of application state
  }
  
  # UI description to render
  ui: {
    layout: {
      direction: horizontal
      panes: [
        {
          widget: {
            type: "list"
            id: "file_list"      # Required for event targeting
            items: ["file1.txt", "file2.txt", "document.txt"]
            selected: 3
            scrollable: true
            title: "Files"
          }
          size: "30%"
        }
        {
          widget: {
            type: "text"
            content: "Document contents here..."
            wrap: true
            title: "Preview"
          }
          size: "*"
        }
      ]
    }
    
    # Global UI settings
    cursor_visible: false
    title: "File Browser"
  }
}
```

### Example Render Function (Nu)
```nu
let render = {|state, events|
  # Process events to produce new state
  let new_state = $events | reduce --fold $state {|event, acc|
    match $event {
      # Navigation events
      {type: "key", key: "j", widget_id: "file_list"} => {
        $acc | update cursor (($acc.cursor + 1) | math min (($acc.items | length) - 1))
      }
      {type: "key", key: "k", widget_id: "file_list"} => {
        $acc | update cursor (($acc.cursor - 1) | math max 0)
      }
      
      # Selection events
      {type: "key", key: "enter", widget_id: "file_list"} => {
        let selected = $acc.items | get $acc.cursor
        $acc | update preview (open $selected.name | str substring 0..1000)
      }
      {type: "select", index: $idx, widget_id: "file_list"} => {
        $acc | update cursor $idx
      }
      
      # Global events
      {type: "key", key: "q"} => (exit) # Global quit, no widget_id needed
      {type: "resize", width: $w, height: $h} => {
        $acc | update terminal {width: $w, height: $h}
      }
      
      # Ignore unhandled events
      _ => $acc
    }
  }
  
  # Return both new state and UI description
  {
    state: $new_state
    ui: {
      layout: {
        direction: horizontal
        panes: [
          {
            widget: {
              type: "list"
              id: "file_list"
              items: ($new_state.items | get name)
              selected: $new_state.cursor
              title: "Files"
            }
            size: "30%"
          }
          {
            widget: {
              type: "text"
              content: $new_state.preview
              title: "Preview"
            }
            size: "*"
          }
        ]
      }
      title: $"File Browser - ($new_state.items | length) items"
    }
  }
}
```

## Plugin Implementation Details

### Simple Plugin Structure (using nu-plugin crate)
```rust
use nu_plugin::{serve_plugin, Plugin, SimplePluginCommand, MsgPackSerializer};
use nu_plugin::{EngineInterface, EvaluatedCall};
use nu_protocol::{LabeledError, Signature, Value, Type};

struct DatatUI;
struct RunCommand;

impl Plugin for DatatUI {
    fn version(&self) -> String {
        env!("CARGO_PKG_VERSION").into()
    }

    fn commands(&self) -> Vec<Box<dyn PluginCommand<Plugin = Self>>> {
        vec![Box::new(RunCommand)]
    }
}

impl SimplePluginCommand for RunCommand {
    type Plugin = DatatUI;

    fn name(&self) -> &str {
        "datatui run"
    }

    fn signature(&self) -> Signature {
        Signature::build("datatui run")
            .named("state", SyntaxShape::Any, "Initial state", Some('s'))
            .named("render", SyntaxShape::Closure(Some(vec![SyntaxShape::Any])), 
                   "Render closure", Some('r'))
            .named("events", SyntaxShape::Record, "Event handlers", Some('e'))
    }

    fn description(&self) -> &str {
        "Run a datatui application"
    }

    fn run(
        &self,
        plugin: &DatatUI,
        engine: &EngineInterface,
        call: &EvaluatedCall,
        input: &Value,
    ) -> Result<Value, LabeledError> {
        let initial_state = call.get_flag_value("state")?;
        let render_closure = call.get_flag_value("render")?;
        let event_handlers = call.get_flag_value("events")?;
        
        run_tui_loop(engine, initial_state, render_closure, event_handlers)
    }
}

fn main() {
    serve_plugin(&DatatUI, MsgPackSerializer);
}

// The actual TUI loop implementation
fn run_tui_loop(
    engine: &EngineInterface,
    mut current_state: Value,
    render_closure: Value,
) -> Result<Value, LabeledError> {
    let mut terminal = setup_terminal()?;
    let mut events_buffer = Vec::new();
    let mut focused_widget_id = "main".to_string(); // Track focus for event targeting
    
    loop {
        // 1. Call Nu render closure with current state and collected events
        let result = engine.eval_closure_with_stream(
            &render_closure,
            vec![
                current_state.clone(),
                Value::List { 
                    vals: events_buffer.clone(),
                    span: Span::unknown()
                }
            ],
            PipelineData::Empty,
            false, // Don't redirect stdout
        )?.into_value(Span::unknown())?;
        
        // 2. Extract new state and UI description
        let render_result = result.as_record()?;
        current_state = render_result.get("state")?.clone();
        let ui_description = render_result.get("ui")?;
        
        // 3. Clear events buffer for next frame
        events_buffer.clear();
        
        // 4. Render UI using ratatui
        terminal.draw(|frame| {
            render_from_description(frame, ui_description, &mut focused_widget_id)
        })?;
        
        // 5. Collect events for next frame
        if let Ok(event) = crossterm::event::poll(Duration::from_millis(16)) {
            if event {
                match crossterm::event::read()? {
                    Event::Key(key_event) => {
                        events_buffer.push(create_key_event_value(
                            key_event, 
                            &focused_widget_id
                        ));
                    }
                    Event::Resize(w, h) => {
                        events_buffer.push(create_resize_event_value(w, h));
                    }
                    Event::Mouse(mouse_event) => {
                        // Handle mouse events, update focused_widget_id if needed
                        if let Some(widget_event) = handle_mouse_event(mouse_event, ui_description) {
                            events_buffer.push(widget_event);
                        }
                    }
                }
            }
        }
    }
}

// Helper functions for creating Nu Value events
fn create_key_event_value(key_event: KeyEvent, widget_id: &str) -> Value {
    Value::Record {
        cols: vec![
            "type".to_string(),
            "key".to_string(), 
            "widget_id".to_string(),
            "modifiers".to_string(),
            "timestamp".to_string(),
        ],
        vals: vec![
            Value::String { val: "key".to_string(), span: Span::unknown() },
            Value::String { val: format!("{:?}", key_event.code), span: Span::unknown() },
            Value::String { val: widget_id.to_string(), span: Span::unknown() },
            Value::List { 
                vals: key_event.modifiers.iter().map(|m| 
                    Value::String { val: format!("{:?}", m), span: Span::unknown() }
                ).collect(),
                span: Span::unknown()
            },
            Value::Int { val: chrono::Utc::now().timestamp_millis(), span: Span::unknown() },
        ],
        span: Span::unknown(),
    }
}
```

### Widget Rendering
```rust
fn render_widget(frame: &mut Frame, area: Rect, widget_desc: &Value) -> Result<()> {
    match widget_desc.get("type")?.as_string()? {
        "list" => {
            let items = extract_list_items(widget_desc)?;
            let selected = widget_desc.get("selected")?.as_int()? as usize;
            
            let list = List::new(items)
                .highlight_style(Style::default().reversed())
                .highlight_symbol(">> ");
                
            let mut list_state = ListState::default();
            list_state.select(Some(selected));
            
            frame.render_stateful_widget(list, area, &mut list_state);
        }
        "text" => {
            let content = widget_desc.get("content")?.as_string()?;
            let paragraph = Paragraph::new(content);
            frame.render_widget(paragraph, area);
        }
        // ... other widget types
    }
}
```

### Nu-Rust Communication (Handled by nu-plugin)
```rust
// The nu-plugin crate handles all serialization automatically!
// No need to manually implement JSON-RPC or value conversion.

// Just use the EngineInterface to call Nu closures:
fn call_nu_closure(
    engine: &EngineInterface,
    closure: &Value,  // Nu closure value
    args: Vec<Value>, // Arguments to pass
) -> Result<Value, LabeledError> {
    let result = engine.eval_closure_with_stream(
        closure,
        args,
        PipelineData::Empty,
        false, // Don't redirect stdout
    )?;
    
    // Convert PipelineData back to Value
    result.into_value(Span::unknown())
}

// The plugin framework automatically:
// - Serializes/deserializes Nu Values 
// - Handles the JSON-RPC protocol
// - Manages stdin/stdout communication
// - Provides error handling
```

## Error Handling Strategy

### Graceful Degradation
- **Plugin crashes**: Return control to Nu with error message
- **Nu closure errors**: Show error in UI, allow retry
- **Terminal errors**: Cleanup terminal state before exit

### Recovery Mechanisms
```rust
// Example: Handle Nu closure execution errors
match call_nu_closure(&render_closure, &current_state) {
    Ok(ui_desc) => render_ui(ui_desc),
    Err(e) => {
        // Show error in terminal, allow user to fix and retry
        render_error_message(&e);
        // Keep previous state, wait for user input
    }
}
```

## Performance Considerations

### Optimization Targets
- **State serialization**: Minimize JSON overhead for large datasets
- **Render frequency**: Only re-render on state changes
- **Widget caching**: Leverage ratatui's layout cache
- **Event handling**: Efficient key mapping and dispatch

### Scalability Limits
- **Dataset size**: Target < 10k items for smooth interaction  
- **State complexity**: Deep nesting may impact serialization
- **Update frequency**: Real-time updates limited by Nu closure call overhead

## Testing Strategy

### Unit Tests (Rust)
- Widget rendering with various configurations
- State serialization/deserialization
- Event handler dispatch
- Terminal state management

### Integration Tests (Nu + Rust)
- Full event loop cycle
- Complex state transformations
- Multi-widget layouts
- Error recovery scenarios

### Real-world Validation
- Port jjiles to use datatui
- Build nucess as reference implementation
- Performance testing with large datasets
- User experience validation

## Security Considerations

### Plugin Sandbox
- Plugin cannot access filesystem directly (Nu handles all I/O)
- Terminal control is isolated to plugin process
- Nu closures execute in normal Nu security context

### Input Validation
- Validate UI descriptions from Nu before rendering
- Sanitize terminal control sequences
- Bounds checking for widget dimensions and positions